package edu.uncc.sis.aside.auxiliary.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.eclipse.core.filebuffers.FileBuffers;
import org.eclipse.core.filebuffers.ITextFileBuffer;
import org.eclipse.core.filebuffers.ITextFileBufferManager;
import org.eclipse.core.filebuffers.LocationKind;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.NodeFinder;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ITrackedNodePosition;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.Position;
import org.eclipse.jface.text.source.Annotation;
import org.eclipse.jface.text.source.IAnnotationModel;
import org.eclipse.text.edits.MalformedTreeException;
import org.eclipse.text.edits.TextEdit;

import edu.uncc.sis.aside.ast.ASTResolving;
import edu.uncc.sis.aside.visitors.FindNodeVisitor;

public class CodeGenerator {
	
	private static final String ANNOTATION_TYPE = "edu.uncc.sis.aside.invisibleAnnotation";
	
	private static final String ESAPI_IMPORT = "org.owasp.esapi.ESAPI";
	private static final String ESAPI_VALIDATION_EXCEPTION_IMPORT = "org.owasp.esapi.errors.IntrusionException";
	private static final String ESAPI_INTRUSION_EXCEPTION_IMPORT = "org.owasp.esapi.errors.ValidationException";
	private static final String EXCEPTION_VARIABLE_NAME = "e";
	private static final String VALIDATION_EXCEPTION_TYPE = "ValidationException";
	private static final String INTRUSION_EXCEPTION_TYPE = "IntrusionException";

	private static final String ESAPI = "ESAPI";
	private static final String ESAPI_VALIDATOR = "validator";
	private static final String ESAPI_ENCODER = "encoder";
	private static final String ESAPI_VALIDATOR_GETVALIDINPUT = "getValidInput";

	private static final String ESAPI_CONTEXT_PLACEHOLDER = "replace ME with validation context";
	private static final String ESAPI_COMMENT = "// NOTE: Input Validation code generated by ASIDE";
	private static final String ESAPI_DEFAULT_LENGTH = "200"; // TODO

	private static CodeGenerator instance = null;

	private CodeGenerator() {

	}

	public static CodeGenerator getInstance() {

		if (instance == null) {

			synchronized (CodeGenerator.class) {
				instance = new CodeGenerator();
			}

		}

		return instance;
	}

	/**
	 * There are essentially four cases: 1. ... String string = a.b(); ...
	 * 
	 * 2. String s; ... s = a.b(); ...
	 * 
	 * 3. ... c.d(a.b(), Object s); ...
	 * 
	 * 4. ... f = c.d(a.b(), Object s); ...
	 * 
	 * The correct format of validation is:
	 * 
	 * boolean _valid = false; // this should be declared as the first statement
	 * of the parent method declaration ... _valid = Pattern.matches(String
	 * regex, String input);
	 * 
	 * if(_valid){
	 * 
	 * // the following sibling statements
	 * 
	 * }else{ // If possible, leave a comment as a reminder }
	 * 
	 */
	
	public void generateValidationRoutine(IDocument document,
			CompilationUnit astRoot, ImportRewrite fImportRewrite, AST ast,
			ASTNode node, String inputType) {
		if (inputType == null || inputType.equals("")) {
			inputType = "UNKNOWN";
		}

		ASTRewrite fASTRewrite = ASTRewrite.create(ast);
		TextEdit importEdits = null, textEdits = null;

		/*
		 * Syntactic checking against regular expressions
		 */

		Statement statement = ASTResolving.findParentStatement(node);
		if (statement == null) {
			System.out
					.println("cannot resolve the statement that contains the selected node");
			return;
		}

		StructuralPropertyDescriptor location = statement.getLocationInParent();

		if (location == null || location.isChildProperty()
				|| !location.isChildListProperty()) {
			return;
		}

		try {
			if (statement instanceof ExpressionStatement) {

				ExpressionStatement expressionStatement = (ExpressionStatement) statement;
				Expression expression = expressionStatement.getExpression();
				ASTNode parent = node.getParent();

				/* String s; ... s = a.b(); ... */
				if (parent == expression && parent instanceof Assignment) {
					Assignment assignment = (Assignment) parent;
					
					Map<ITrackedNodePosition, ArrayList<ASTNode>> annotatedStatementsMap = new HashMap<ITrackedNodePosition, ArrayList<ASTNode>>();
					
					fASTRewrite = _refactoringCode(fASTRewrite, ast, inputType,
							statement, assignment, location);
					textEdits = fASTRewrite.rewriteAST();
					fImportRewrite.addImport(ESAPI_IMPORT);
					fImportRewrite.addImport(ESAPI_VALIDATION_EXCEPTION_IMPORT);
					fImportRewrite.addImport(ESAPI_INTRUSION_EXCEPTION_IMPORT);
					importEdits = fImportRewrite.rewriteImports(null);
					textEdits.apply(document, TextEdit.CREATE_UNDO
							| TextEdit.UPDATE_REGIONS);
					importEdits.apply(document, TextEdit.CREATE_UNDO
							| TextEdit.UPDATE_REGIONS);
					
					int importLength = importEdits.getLength();
					CompilationUnit newRoot = parse(document);

					copyAnnotation(annotatedStatementsMap, newRoot, importLength);
					
					return;
				}

				/* ... c.d(a.b(), ...); ... */
				if (parent == expression && parent instanceof MethodInvocation) {

					ArrayList<ITrackedNodePosition> list = new ArrayList<ITrackedNodePosition>();
					fASTRewrite = _refactoringCode2(fASTRewrite, ast,
							inputType, statement, node, location);
					textEdits = fASTRewrite.rewriteAST();

					fImportRewrite.addImport(ESAPI_IMPORT);
					fImportRewrite.addImport(ESAPI_VALIDATION_EXCEPTION_IMPORT);
					fImportRewrite.addImport(ESAPI_INTRUSION_EXCEPTION_IMPORT);
					importEdits = fImportRewrite.rewriteImports(null);
					textEdits.apply(document, TextEdit.CREATE_UNDO
							| TextEdit.UPDATE_REGIONS);
					importEdits.apply(document, TextEdit.CREATE_UNDO
							| TextEdit.UPDATE_REGIONS);
					
					int importLength = importEdits.getLength();
					CompilationUnit newRoot = parse(document);

					ITrackedNodePosition trackPosition = list.get(0);

					copyAnnotation(trackPosition, node, newRoot,
							importLength);
					
					return;
				}

				/* Object s; ... s = c.d(a.b(), ...); ... */
				ASTNode grandNode = parent.getParent();
				if (grandNode != null && grandNode == expression
						&& parent instanceof MethodInvocation) {

					return;
				}
			}

			if (statement instanceof VariableDeclarationStatement) {

				VariableDeclarationFragment fragment = (VariableDeclarationFragment) node
						.getParent();

				if (fragment == null) {
					return;
				}
				Map<ITrackedNodePosition, ArrayList<ASTNode>> annotatedStatementsMap = new HashMap<ITrackedNodePosition, ArrayList<ASTNode>>();
				ArrayList<ITrackedNodePosition> originalNodePositionList = new ArrayList<ITrackedNodePosition>();
				/* ... String string = a.b(); ... */
				fASTRewrite = _refactoringCode(fASTRewrite, ast, inputType,
						statement, fragment, location);
				textEdits = fASTRewrite.rewriteAST();
				fImportRewrite.addImport(ESAPI_IMPORT);
				fImportRewrite.addImport(ESAPI_VALIDATION_EXCEPTION_IMPORT);
				fImportRewrite.addImport(ESAPI_INTRUSION_EXCEPTION_IMPORT);
				textEdits.apply(document, TextEdit.CREATE_UNDO
						| TextEdit.UPDATE_REGIONS);
				importEdits = fImportRewrite.rewriteImports(null);

				importEdits.apply(document, TextEdit.CREATE_UNDO
						| TextEdit.UPDATE_REGIONS);
				
				int importLength = importEdits.getLength();
				CompilationUnit newRoot = parse(document);

				copyAnnotation(annotatedStatementsMap, newRoot, importLength);

				ITrackedNodePosition trackPosition = originalNodePositionList
						.get(0);
				copyAnnotation(trackPosition, node, newRoot, importLength);

				return;
			}
		} catch (CoreException e) {
			e.printStackTrace();
		} catch (MalformedTreeException e) {
			e.printStackTrace();
		} catch (BadLocationException e) {
			e.printStackTrace();
		}

	}

	private ASTRewrite _refactoringCode(ASTRewrite fASTRewrite, AST ast,
			String inputType, Statement statement, ASTNode node,
			StructuralPropertyDescriptor location) {

		TryStatement tryStatement = ast.newTryStatement();

		MethodInvocation esapiValidator = ast.newMethodInvocation();
		esapiValidator.setExpression(ast.newSimpleName(ESAPI));
		esapiValidator.setName(ast.newSimpleName(ESAPI_VALIDATOR));

		MethodInvocation esapiValidation = ast.newMethodInvocation();
		esapiValidation.setExpression(esapiValidator);
		esapiValidation.setName(ast
				.newSimpleName(ESAPI_VALIDATOR_GETVALIDINPUT));

		List<ASTNode> arguments = esapiValidation.arguments();

		StringLiteral contextArg = ast.newStringLiteral();
		contextArg.setLiteralValue(ESAPI_CONTEXT_PLACEHOLDER);
		arguments.add(0, contextArg);
		if (node instanceof VariableDeclarationFragment) {
			VariableDeclarationFragment fragment = (VariableDeclarationFragment) node;
			arguments.add(1, fASTRewrite.createCopyTarget(fragment.getName()));
		} else if (node instanceof Assignment) {
			Assignment assignment = (Assignment) node;
			arguments.add(1, fASTRewrite.createCopyTarget(assignment
					.getLeftHandSide()));
		}

		StringLiteral inputTypeArg = ast.newStringLiteral();
		inputTypeArg.setLiteralValue(inputType);
		// inputTypeArg.setLiteralValue(ESAPI_INPUT_TYPE);
		arguments.add(2, inputTypeArg);

		NumberLiteral lengthArg = ast.newNumberLiteral(ESAPI_DEFAULT_LENGTH);
		arguments.add(3, lengthArg);

		BooleanLiteral allowNullArg = ast.newBooleanLiteral(false);
		arguments.add(4, allowNullArg);

		Block tryBlock = ast.newBlock();
		ExpressionStatement tryBodyStatement = ast
				.newExpressionStatement(esapiValidation);

		tryBlock.statements().add(tryBodyStatement);

		tryStatement.setBody(tryBlock);

		// catch (ValidationException e) { }
		CatchClause validationExceptionClause = ast.newCatchClause();
		SingleVariableDeclaration veFormalParameter = ast
				.newSingleVariableDeclaration();
		veFormalParameter.setName(ast.newSimpleName(EXCEPTION_VARIABLE_NAME));
		veFormalParameter.setType(ast.newSimpleType(ast
				.newName(VALIDATION_EXCEPTION_TYPE)));

		validationExceptionClause.setException(veFormalParameter);

		Block veClauseBody = ast.newBlock();
		validationExceptionClause.setBody(veClauseBody);

		// catch (IntrusionException e) { }
		CatchClause intrusionExceptionClause = ast.newCatchClause();
		SingleVariableDeclaration ieFormalParameter = ast
				.newSingleVariableDeclaration();
		ieFormalParameter.setName(ast.newSimpleName(EXCEPTION_VARIABLE_NAME));
		ieFormalParameter.setType(ast.newSimpleType(ast
				.newName(INTRUSION_EXCEPTION_TYPE)));

		intrusionExceptionClause.setException(ieFormalParameter);

		Block ieClauseBody = ast.newBlock();
		intrusionExceptionClause.setBody(ieClauseBody);

		tryStatement.catchClauses().add(validationExceptionClause);
		tryStatement.catchClauses().add(intrusionExceptionClause);

		LineComment notice = (LineComment) fASTRewrite.createStringPlaceholder(
				ESAPI_COMMENT, ASTNode.LINE_COMMENT);

		ListRewrite fListRewrite = fASTRewrite
				.getListRewrite(ASTResolving
						.getParent(statement, ASTNode.BLOCK),
						Block.STATEMENTS_PROPERTY);

		fListRewrite.insertAfter(tryStatement, statement, null);
		fListRewrite.insertBefore(notice, tryStatement, null);

		return fASTRewrite;
	}

	private ASTRewrite _refactoringCode2(ASTRewrite fASTRewrite, AST ast,
			String inputType, Statement statement, ASTNode coveringNode,
			StructuralPropertyDescriptor location) {

		TryStatement tryStatement = ast.newTryStatement();

		MethodInvocation esapiValidator = ast.newMethodInvocation();
		esapiValidator.setExpression(ast.newSimpleName(ESAPI));
		esapiValidator.setName(ast.newSimpleName(ESAPI_VALIDATOR));

		MethodInvocation esapiValidation = ast.newMethodInvocation();
		esapiValidation.setExpression(esapiValidator);
		esapiValidation.setName(ast
				.newSimpleName(ESAPI_VALIDATOR_GETVALIDINPUT));

		StringLiteral contextArg = ast.newStringLiteral();
		contextArg.setLiteralValue(ESAPI_CONTEXT_PLACEHOLDER);
		List<ASTNode> arguments = esapiValidation.arguments();
		arguments.add(0, contextArg);
		arguments.add(1, fASTRewrite.createCopyTarget(coveringNode));

		StringLiteral inputTypeArg = ast.newStringLiteral();
		inputTypeArg.setLiteralValue(inputType);
		// inputTypeArg.setLiteralValue(ESAPI_INPUT_TYPE);
		arguments.add(2, inputTypeArg);

		NumberLiteral lengthArg = ast.newNumberLiteral(ESAPI_DEFAULT_LENGTH);
		arguments.add(3, lengthArg);

		BooleanLiteral allowNullArg = ast.newBooleanLiteral(false);
		arguments.add(4, allowNullArg);

		Block tryBlock = ast.newBlock();
		ExpressionStatement tryBodyStatement = ast
				.newExpressionStatement(esapiValidation);

		tryBlock.statements().add(tryBodyStatement);

		tryStatement.setBody(tryBlock);

		CatchClause validationExceptionClause = ast.newCatchClause();
		SingleVariableDeclaration veFormalParameter = ast
				.newSingleVariableDeclaration();
		veFormalParameter.setName(ast.newSimpleName(EXCEPTION_VARIABLE_NAME));
		veFormalParameter.setType(ast.newSimpleType(ast
				.newName(VALIDATION_EXCEPTION_TYPE)));

		validationExceptionClause.setException(veFormalParameter);

		Block veClauseBody = ast.newBlock();
		validationExceptionClause.setBody(veClauseBody);

		CatchClause intrusionExceptionClause = ast.newCatchClause();
		SingleVariableDeclaration ieFormalParameter = ast
				.newSingleVariableDeclaration();
		ieFormalParameter.setName(ast.newSimpleName(EXCEPTION_VARIABLE_NAME));
		ieFormalParameter.setType(ast.newSimpleType(ast
				.newName(INTRUSION_EXCEPTION_TYPE)));

		validationExceptionClause.setException(ieFormalParameter);

		Block ieClauseBody = ast.newBlock();
		intrusionExceptionClause.setBody(veClauseBody);

		tryStatement.catchClauses().add(validationExceptionClause);
		tryStatement.catchClauses().add(intrusionExceptionClause);

		LineComment notice = (LineComment) fASTRewrite.createStringPlaceholder(
				ESAPI_COMMENT, ASTNode.LINE_COMMENT);

		ListRewrite fListRewrite = fASTRewrite
				.getListRewrite(ASTResolving
						.getParent(statement, ASTNode.BLOCK),
						Block.STATEMENTS_PROPERTY);

		fListRewrite.insertAfter(tryStatement, statement, null);
		fListRewrite.insertBefore(notice, tryStatement, null);

		Block ifThen = ast.newBlock();
		ifThen.statements().add(fASTRewrite.createCopyTarget(statement));

		return fASTRewrite;
	}

	private void copyAnnotation(
			Map<ITrackedNodePosition, ArrayList<ASTNode>> annotatedStatements,
			CompilationUnit astRoot, int extra) {
		
		IJavaElement javaElement = astRoot.getJavaElement();
		if(javaElement ==null){
			return;
		}
		
		ICompilationUnit fCompilationUnit = (ICompilationUnit) javaElement.getAncestor(IJavaElement.COMPILATION_UNIT);
		
		Set<Entry<ITrackedNodePosition, ArrayList<ASTNode>>> entrySet = annotatedStatements
				.entrySet();
		for (Entry<ITrackedNodePosition, ArrayList<ASTNode>> entry : entrySet) {
			ITrackedNodePosition position = entry.getKey();
			int start = position.getStartPosition() + extra;
			int length = position.getLength();
			NodeFinder nodeFinder = new NodeFinder(astRoot, start, length);
			ASTNode coveredNode = nodeFinder.getCoveredNode();

			ArrayList<ASTNode> annotatedNodes = entry.getValue();
			for (ASTNode node : annotatedNodes) {
				FindNodeVisitor visitor = new FindNodeVisitor(coveredNode, node);
				visitor.process();
				ASTNode match = visitor.getNode();
				if (match != null) {
					createAnnotationAtPosition(fCompilationUnit, match);
				}
			}

		}
	}

	public void generateEncodingRoutine(IDocument document,
			ImportRewrite fImportRewrite, AST ast,
			MethodDeclaration declaration, Expression node, String methodName) throws IllegalArgumentException,
			CoreException, MalformedTreeException, BadLocationException {
		
		ICompilationUnit fCompilationUnit = fImportRewrite.getCompilationUnit();
		
		fImportRewrite.addImport(ESAPI_IMPORT);
		
		ASTRewrite fASTRewrite = ASTRewrite.create(ast);
		TextEdit importEdits = null, textEdits = null;

		Statement statement = ASTResolving.findParentStatement(node);

		if (!(statement instanceof ExpressionStatement)) {
			return;
		}

		ExpressionStatement expressionStatement = (ExpressionStatement) statement;
		Expression expression = expressionStatement.getExpression();

		ASTNode parent = node.getParent();
		if (parent == null || parent != expression) {
			return;
		}

		MethodInvocation replacement = ast.newMethodInvocation();
		ITrackedNodePosition position = fASTRewrite.track(replacement);
		MethodInvocation _expression = ast.newMethodInvocation();
        _expression.setExpression(ast.newSimpleName(ESAPI));
	    _expression.setName(ast.newSimpleName(ESAPI_ENCODER));
		
		replacement.setExpression(_expression);
		replacement.setName(ast.newSimpleName(methodName));
		
		List<Expression> arguments = replacement.arguments();
		Expression copyOfCoveredNode = (Expression) fASTRewrite
				.createCopyTarget(node);

		arguments.add(0, copyOfCoveredNode);

		LineComment notice = (LineComment) fASTRewrite.createStringPlaceholder(
				"// NOTE: Encoding code generated by ASIDE",
				ASTNode.LINE_COMMENT);

		ListRewrite listRewrite = fASTRewrite.getListRewrite(
				ASTResolving.getParent(statement, ASTNode.BLOCK),
				Block.STATEMENTS_PROPERTY);
		listRewrite.insertBefore(notice, statement, null);

		fASTRewrite.replace(node, replacement, null);

		textEdits = fASTRewrite.rewriteAST();
		importEdits = fImportRewrite.rewriteImports(null);
		textEdits.apply(document, TextEdit.CREATE_UNDO
				| TextEdit.UPDATE_REGIONS);
		importEdits.apply(document, TextEdit.CREATE_UNDO
				| TextEdit.UPDATE_REGIONS);

		int charStart = position.getStartPosition() + importEdits.getLength();
		int length = position.getLength();

		createAnnotationAtPosition(fCompilationUnit, charStart, length);
	}
	
	
	private void copyAnnotation(ITrackedNodePosition trackPosition,
			ASTNode node, CompilationUnit astRoot, int extra) {
		
		IJavaElement javaElement = astRoot.getJavaElement();
		if(javaElement ==null){
			return;
		}
		
		ICompilationUnit fCompilationUnit = (ICompilationUnit) javaElement.getAncestor(IJavaElement.COMPILATION_UNIT);
		
		int start = trackPosition.getStartPosition() + extra;
		int length = trackPosition.getLength();
		NodeFinder nodeFinder = new NodeFinder(astRoot, start, length);
		ASTNode coveredNode = nodeFinder.getCoveredNode();
		FindNodeVisitor visitor = new FindNodeVisitor(coveredNode, node);
		visitor.process();
		ASTNode match = visitor.getNode();
		if (match != null) {
			createAnnotationAtPosition(fCompilationUnit, match);
		}
	}
	
	private void createAnnotationAtPosition(ICompilationUnit fCompilationUnit,
			ASTNode node) {
		
		int start = node.getStartPosition();
		int length = node.getLength();
		createAnnotationAtPosition(fCompilationUnit, start, length);

	}

	private Annotation getAttachedAnnoation(ICompilationUnit fCompilationUnit, ASTNode target) {

		ITextFileBufferManager manager = FileBuffers.getTextFileBufferManager();
		ITextFileBuffer buffer = manager.getTextFileBuffer(
				fCompilationUnit.getPath(), LocationKind.IFILE);
		if (buffer == null) {
			return null;
		}

		IAnnotationModel model = buffer.getAnnotationModel();

		Iterator<Annotation> iterator = model.getAnnotationIterator();
		Annotation annotation;
		Position position;
		while (iterator.hasNext()) {
			annotation = iterator.next();
			if (annotation.getType().equals(ANNOTATION_TYPE)) {
				position = model.getPosition(annotation);
				if (position.getOffset() == target.getStartPosition()
						&& position.getLength() == target.getLength()) {
					return annotation;
				}
			}
		}

		return null;
	}

	private void createAnnotationAtPosition(ICompilationUnit fCompilationUnit, int start, int length) {

		Position newPosition = new Position(start, length);
		Annotation fixedAnnotation = new Annotation(ANNOTATION_TYPE, true, null);
		ITextFileBufferManager manager = FileBuffers.getTextFileBufferManager();
		ITextFileBuffer buffer = manager.getTextFileBuffer(
				fCompilationUnit.getPath(), LocationKind.IFILE);
		IAnnotationModel model = buffer.getAnnotationModel();

		model.addAnnotation(fixedAnnotation, newPosition);
	}	
	
	private CompilationUnit parse(IDocument document) {
		ASTParser parser = ASTParser.newParser(AST.JLS3);
		parser.setKind(ASTParser.K_COMPILATION_UNIT);
		parser.setSource(document.get().toCharArray());
		parser.setResolveBindings(true);
		CompilationUnit root = (CompilationUnit) parser.createAST(null);

		return root;
	}
}
